# for-my-dream
## 这是yyt6801的梦想之路：(只要梦还在，更新就不停...)
### 工程师-->全栈工程师-->架构师-->程序员（最终信仰）

# 文件介绍：
    wechat_redPackage            wechat随机红包实现方式-java
    Demon_Gan.txt                windows黑客编程在线交流笔记。
    README.me                    个人随笔、知识体系、想学习的知识汇总分类。
    SocketClient.cpp
    SocketServer.cpp             是Socket通讯的两个测试程序，本不区分Client和Server,但为了方便，取建立监听的为Server,发起请求的为Client。  
    char型转换.cpp               对char型、字符型、文本型字符转换赋值等操作的测试程序。 因为对方面不太清晰，用来测试和方便后期查阅。
    formyself.txt               一些个人琐事灵感等
    git基本操作.docx             git的基本操作汇总  
    myLearnNotes.md             个人学习笔记
    test123.cpp                 个人的测试程序代码（包括获取文件 1.txt的内容；调用windowsAPI-MessageBox；通过互斥对象句柄检测程序是否运行）
----------------------------------
# 知识体系：
汇编-->内核编程-->c/c++-->python、java、
## 基础知识
计算机网络－离散数学－数据库原理－编译原理－计算机操作系统－软件工程－算法－设计模式
### JAVA知识:
JAVA基础-容器-并发-JVM-MySQL(或其他数据库)-Redis-RocketMQ(或其他消息中间件)-Git-Docker-Spring-SpringMVC-SpringBoot-SpringCloud

## 计算机网络
### 4/7层模型
|4层模型|对应7层模型|作用|协议举例|
|----|----|----|----|
|应用层|应用层|应用层为操作系统或网络应用程序提供访问网络服务的接口|Telnet（Internet远程登录服务的标准协议和主要方式）、FTP（文件传输协议）、HTTP（超文本传送协议）、SNMP（简单网络管理协议）|
|\|______|表示层|表示层对上层数据或信息进行变换以保证一个主机应用层信息可以被另一个主机的应用程序理解|表示层的数据转换包括数据的加密、压缩、格式转换等
|传输层|会话层|会话层管理主机之间的会话进程，即负责建立、管理、终止进程之间的会话;会话层还利用在数据中插入校验点来实现数据的同步
|\|______|传输层|传输层是第一个端到端，即主机到主机的层次；传输层负责将上层数据分段并提供端到端的、可靠的或不可靠的传输；传输层还要处理端到端的差错控制和流量控制问题；数据的单位称为数据段(segment)|TCP（传输控制协议）、UDP（用户数据报协议）、SPX（序列分组交换协议）
|网间层|网络层|网络层负责对子网间的数据包进行路由选择，还可以实现拥塞控制、网际互连等功能，数据的单位称为数据包(packet)|IP（网络之间互联的协议）、IPX（互联网数据包交换协议）、RIP（路由信息协议）、OSPF（开放式最短路径优先）|
|网络接口|数据链路层|数据链路层在不可靠的物理介质上提供可靠的传输;物理地址寻址、数据的成帧、流量控制、数据的检错、重发等;数据的单位称为比特(bit)。以太网帧。最小64bytes;最大1518bytes。|SDLC（同步数据链路控制）、HDLC（高级数据链路控制）、PPP（点对点协议）、STP（生成树协议）、帧中继
|\|______|物理层|该层为上层协议提供了一个传输数据的物理媒体。数据的单位称为比特（bit）|EIA/TIA RS-232、EIA/TIA RS-449、V.35、RJ-45


    TCP/IP协议
    (三次握手四次挥手，报文状态标志，Nagel算法与ACK延迟，keepalive开启/关闭方式，滑动窗口，流量控制)、

    UDP协议、

    HTTP协议(method,header,cookies,状态码，HTTP2,HTTP3)

    操作系统原理:进程与线程的区别和联系，线程调度，线程切换步骤，进程间通信(IPC)，共享内存，消息队列，

  
----------------------------
#### “计算机组成原理 → DOS命令 → 汇编语言 → C语言（不包括C++）、代码书写规范 → 数据结构、编译原理、操作系统 → 计算机网络、数据库原理、正则表达式 → 其它语言（包括C++）、架构……”

## 编译&汇编过程
    编译: 源代码-->机器语言
    链接：把①目标文件②操作系统的启动代码③库文件-->组织生成可执行程序

    汇编语言(.s文件?)通过编译器生成机器语言(0和1)。其中编译器所使用的规则即是指令集。

    编译过程：  源代码(.c/.cpp文件) --编译器-->> 汇编语言(.s文件) --汇编器-->> 目标代码(.o文件) 

    链接过程：  目标代码(.o文件)+其他目标代码+库文件 --连接器--> 可执行文件(.exe文件)

    指令集：是CPU选择的语言，微架构(即各厂商的核心技术)是具体的实现。 x86-复杂指令集；ARM-精简指令集。
## 汇编
    把汇编换算成二进制机器码。
    比如：MOV CL,55H 对应的机器码为: B155
    不是用反汇编编译器查出来的。是用笔算出来的，和反汇编查的是一样的。任何一条汇编语言都可以用笔算出来它的机器码。有对应表。但是还要自己去算二进制。有对应表，也算是固定。但是查不到。对应表也要算二进制。
    例如    汇编                      对应二进制位           对应十六进制
            mov eax,eax                1100 0000              8B C0
            mov eax,ecx                1100 0001              8B C1
            mov eax,edx                1100 0010              8B C2
            mov eax,ebx                1100 0011              8B C3
            mov eax,esp                1100 0100              8B C4
            mov eax,ebp                1100 0101              8B C5
    8B是mov eax，eax的固定二进制。需要研究的就是8B怎么算出来的？还有后面C0是表示什么
    首先，mov eax，eax是扩展的寄存器。在CPU看来和mov ax，ax 机器码是一样的。第二就是看源和目标都是寄存器。mov 寄存器16/32位，寄存器16/32位。他的固定二进制是1000 101*。那第一个就是8。后面那个*是这样算的。如果al，或者ah这种8位的就置0，如果是16/32位就置1。1011换成16进制就是B。   关于寄存器 eax ax ah 和al   使用32位寄存器时，寄存器的0~31位为eax; 使用16位时 0~15位为ax;  而0~7位为al; 8~15位为ah。。
    机器码和汇编语言确实是对应的，但是是有条件的。寄存器位宽会改变机器码的二进制。所以看起来有对应不上，但是可以算出来。改变二进制的位就可以反推算出来使用的是al，还是ax还是eax。 这就是为什么可以把二进制反编译成汇编语言。所以例子中那个C0二进制就是1100 0000。8B C0
----------------------------------
## Linux
#### awk,top,netstat,grep，
### Linux系统工具的使用
#### top,strace,perf,vmstat,sar,tcpdump
---------------------------------
## C/C++ ：
常用数据类型，强制数据类型转换，
string字符串的用法

堆栈的基本原理

在Window下，栈的大小是2MB，Linux下，默认栈空间大小为8MB，可通过ulimit -s来设置.栈的速度快、空间小，不灵活
在Window下，堆的大小一般小于2GB。

注意事项:不静态分配，用new动态创建，从堆中分配的，堆的空间足够大.
不过记得写析构函数，delete你申请的堆空间类结束的时候会自动调用析构函数释放空间。养成"不在栈上定义大数组/大对象"的好习惯很重要，否则再大的栈也会被撑爆的。
当然，如果你不喜欢new，delete的话，还是静态分配（毕竟静态分配有很多好处），那么可以通过改变默认栈空间来解决。

#### c标准库：
##### 1、标准函数库：
输入/输出 I/O；
字符串和字符处理；strcat,strncpy,sprintf
数学；
时间、日期和本地化；
动态分配；
其他；
宽字符函数；
<assert.h>
<ctype.h>
<errno.h>
<float.h>
<limits.h>
<locale.h>
<math.h>
<signal.h>
<stdarg.h>
<stddef.h>
<stdio.h>
<stdlib.h>
<string.h>
<time.h>

## Python

## java :
-------------------------------------------
## 数据库：
#### Oracle
#### MySql
#### SqlServer
#### MongoDB
#### Redis
--------------------------------------
## 前端：
### javascript
### AnjularJS
### jQuery
### React
-------------------------------
## WebSocket协议与socket接口
--------------------------------
## 版本控制
    git基本操作
    svn常用操作
----------------------------------
## 数据结构与算法分析

## 压缩原理及算法
    哈弗曼树，哈弗曼原理（寻找二叉编码的最优算法）

## 加密算法：
    hash函数
    MD5加密

## 海明校验码
    校验码位为：1，2，4，8，16... 2的几次方
    数据位为：3，5，6，7，9，10，11，12，13...   除去校验码的位数
    校验码为：校验码校验位数对应数据的值的异或运算；即相同为1，不同为0
    
## 常用数学算法
    线性回归算法、

## 常用算法
    冒泡排序、二分查找法、图论有最短路径、最小生成树、网络流、拓扑排序

## Docker容器
    docker的一些基本操作
    docker架构
    docker容器使用
    docker镜像使用
    docker容器连接
    容器安装、配置、运行、停止
    
## flutter

## Restful API

## WebService

## Nginx

## Apache

## 小程序

## Windows内核编程

## Ajax
## XML
        ajax获取xml数据，通信
        
## MFC编程-windows窗口编程
     窗口控件、消息（事件）机制、常用事件监听，消息触发

## QT--跨平台C++图形用户界面应用程序开发框架

## 框架和第三方库
#### JAVA--Spring    MyBatis
#### python--Django
#### php--thinkphp
#### nodejs--express

# 大数据相关
## hadoop
-----------------------------------
# InformationSecurity
## CTF

## 渗透

## 无线安全

## 代码审计

## 逆向（反汇编）

## 破解

## SQL注入

#### 52破解
#### 看雪


