# for-my-dream
这是yyt6801的梦想之路：
程序员-->全栈工程师-->架构师-->CCIE最终信仰

#文件介绍：
	README.me 	个人随笔、知识体系、想学习的知识汇总分类。
	SocketClient.cpp和SocketServer.cpp	是Socket通讯的两个测试程序，本不区分Client和Server,但为了方便，取建立监听的为Server,发起请求的为Client。
	char型转换.cpp 	对char型、字符型、文本型字符转换赋值等操作的测试程序。 因为对方面不太清晰，用来测试和方便后期查阅。
	formyself.txt	空
	git基本操作.docx 	git的基本操作汇总
	test123.cpp 	个人的测试程序代码（包括获取文件 1.txt的内容；调用windowsAPI-MessageBox；通过互斥对象句柄检测程序是否运行）

#知识体系：
    计算机网络：4/7层模型、TCP/IP协议(三次握手四次挥手，报文状态标志，Nagel算法与ACK延迟，keepalive开启/关闭方式，滑动窗口，流量控制)、UDP协议、HTTP协议(method,header,cookies,状态码，HTTP2,HTTP3)

    操作系统原理:进程与线程的区别和联系，线程调度，线程切换步骤，进程间通信(IPC)，共享内存，消息队列，

    Linux基本命令：awk,top,netstat,grep，

    C/C++ ：

    WebService:

    java :

    数据库：Oracle:    ;MySql:   ;SqlServer:   ;MongoDB   ;
    
    前端：
        javascript:   ;
        anjularJS:   ;
        JQuery:   ;

    WebSocket通讯；

#计算机基础知识
    编译: 源代码-->机器语言
    链接：把①目标文件②操作系统的启动启动代码③库文件-->组织生成可执行程序
        汇编语言()通过编译器生成机器语言(0和1)。其中编译器所使用的规则即是指令集。
    编译过程：  源代码(.c/.cpp文件) --编译器-->> 汇编语言(.s文件) --汇编器-->> 目标代码(.o文件) 
    链接过程：  目标代码(.o文件)+其他目标代码+库文件 --连接器--> 可执行文件(.exe文件)

    指令集：是CPU选择的语言，微架构(即各厂商的核心技术)是具体的实现。 x86-复杂指令集；ARM-精简指令集。

    汇编:   把汇编换算成二进制机器码。
            比如：MOV CL,55H 对应的机器码为: B155
            不是用反汇编编译器查出来的。是用笔算出来的，和反汇编查的是一样的。任何一条汇编语言都可以用笔算出来它的机器码。有对应表。但是还要自己去算二进制。有对应表，也算是固定。但是查不到。对应表也要算二进制。
            例如 汇编mov eax,eax    对应二进制位 1100 0000      十六进制 8B C0
                    mov eax,ecx                1100 0001              8B C1
                    mov eax,edx                1100 0010              8B C2
                    mov eax,ebx                1100 0011              8B C3
                    mov eax,esp                1100 0100              8B C4
                    mov eax,ebp                1100 0101              8B C5
           8B是mov eax，eax的固定二进制。需要研究的就是8B怎么算出来的？还有后面C0是表示什么
           首先，mov eax，eax是扩展的寄存器。在CPU看来和mov ax，ax 机器码是一样的。第二就是看源和目标都是寄存器。mov 寄存器16/32位，寄存器16/32位。他的固定二进制是1000 101*。那第一个就是8。后面那个*是这样算的。如果al，或者ah这种8位的就置0，如果是16/32位就置1。1011换成16进制就是B。   关于寄存器 eax ax ah 和al   使用32位寄存器时，寄存器的0~31位为eax; 使用16位时 0~15位为ax;  而0~7位为al; 8~15位为ah。。
           机器码和汇编语言确实是对应的，但是是有条件的。寄存器位宽会改变机器码的二进制。所以看起来有对应不上，但是可以算出来。改变二进制的位就可以反推算出来使用的是al，还是ax还是eax。 这就是为什么可以把二进制反编译成汇编语言。所以例子中那个C0二进制就是1100 0000。8B C0
		   
	版本控制：git基本操作
